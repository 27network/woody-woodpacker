/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   elfstream_write.template                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kiroussa <oss@xtrm.me>                     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/17 12:14:40 by kiroussa          #+#    #+#             */
/*   Updated: 2025/05/11 20:16:24 by kiroussa         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef ELF_BITNESS
# error "ELF_BITNESS not defined"
#endif

#include <limits.h>

#define _APPEND(x, y) x##y
#define APPEND(x, y) _APPEND(x, y)

#define Elf(n) APPEND(APPEND(APPEND(Elf, ELF_BITNESS), _), n)
#define Func(n) APPEND(APPEND(n, _x), ELF_BITNESS)

enum e_elfstream_error
Func(elfstream_write_header)(t_elfstream *self, int fd)
{
	const ssize_t	to_write = sizeof(Elf(Ehdr));
	Elf(Ehdr)		*hdr;

	DBG("writing header");
	hdr = (Elf(Ehdr) *) &self->ehdr32;
	if (lseek(fd, 0, SEEK_SET) == -1)
		return (ELFSTREAM_IO);
	hdr->e_phnum = self->segment_count;
	hdr->e_shnum = self->section_count;
	//TODO: shstrndx
	if (write(fd, hdr, to_write) != to_write)
		return (ELFSTREAM_IO);
	DBG("wrote header");
	return (ELFSTREAM_OK);
}

static inline enum e_elfstream_error
Func(elfstream_write_segment)(t_elf_segment *self, int fd)
{
	const ssize_t	to_write = sizeof(Elf(Phdr));
	Elf(Phdr)		*phdr = (Elf(Phdr) *) &self->phdr32;
	Elf(Ehdr)		*ehdr = (Elf(Ehdr) *) &self->stream->ehdr32;

	DBG("writing segment header");
	if (phdr->p_type == PT_PHDR)
	{
		DBG("(re)writing PT_PHDR segment");
		self->content = NULL;
		phdr->p_filesz = ehdr->e_phentsize * self->stream->segment_count;
		phdr->p_memsz = phdr->p_filesz;
		DBG("new size: %#lx", phdr->p_filesz);
	}
	if (write(fd, phdr, to_write) != to_write)
		return (ELFSTREAM_IO);
	DBG("wrote segment header");
	return (ELFSTREAM_OK);
}

static inline enum e_elfstream_error
Func(elfstream_write_content)(off_t offset, t_content_source *content, int fd)
{
	enum e_elfstream_error	error;

	DBG("seeking to %#lx", offset);
	lseek(fd, offset, SEEK_SET);
	DBG("writing content");
	error = ELFSTREAM_OK;
	while (content)
	{
		DBG("writing type %d", (int) content->type);
		if (content->size > 0)
			error = content->write_fn(content, fd);
		if (error)
			break;
		DBG("wrote %#lx content bytes", content->size);
		lseek(fd, offset + content->size, SEEK_SET);
		content = content->next;
	}
	DBG("wrote content");
	return (error);
}

// Find the lowest segment in the stream and return its index
static inline int
Func(elfstream_segment_lowest)(t_elf_segment *segments, size_t count)
{
	int			i;
	size_t		lowest;
	int			lowest_index;
	Elf(Phdr)	*tmp;

	lowest = SIZE_MAX;
	lowest_index = -1;
	DBG("looking for lowest segment");
	i = 0;
	while (i < (int) count)
	{
		tmp = (Elf(Phdr) *) &segments[i].phdr32;
		if (tmp->p_offset == ((Elf(Off)) -1))
		{
			i++;
			continue;
		}
		DBG("segment %zu: offset %#lx, size: %#lx", i, tmp->p_offset, tmp->p_filesz);
		if (tmp->p_offset < lowest)
		{
			DBG("lowest now!");
			lowest = tmp->p_offset;
			lowest_index = i;
		}
		i++;
	}
	DBG("lowest segment is %d", lowest_index);
	return (lowest_index);
}

static inline void
Func(elfstream_segment_coerce)(t_elf_segment *segment, size_t bound)
{
	Elf(Phdr)			*phdr;
	size_t				difference;
	t_content_source	*tmp;

	phdr = (Elf(Phdr) *) &segment->phdr32;
	if (phdr->p_offset < bound)
	{
		DBG("shrinking to hold in bound %#lx", bound);
		difference = bound - phdr->p_offset;
		phdr->p_offset += difference;
		if (phdr->p_filesz < difference)
			phdr->p_filesz = 0;
		else
			phdr->p_filesz -= difference;
		if (phdr->p_memsz < difference)
			phdr->p_memsz = 0;
		else
			phdr->p_memsz -= difference;
		tmp = segment->content;
		while (tmp)
		{
			if (difference >= tmp->size)
			{
				DBG("removing content source as its too small (%#lx)", tmp->size);
				tmp->size = 0;
				difference -= tmp->size;
			}
			else
			{
				DBG("shrinking content source by %#lx", difference);
				if (tmp->type == CONTENT_SOURCE_FILE)
					tmp->s_file.offset += difference;
				tmp->size -= difference;
				difference = 0;
			}
			tmp = tmp->next;
		}
		DBG("new segment size: %#lx", phdr->p_filesz);
	}
}

static inline enum e_elfstream_error
Func(elfstream_write_segments_round)(t_elfstream *self, int fd)
{
	size_t			small_bound;
	t_elf_segment	*segment;
	size_t			i;
	int				smallest;
	off_t			offset;
	Elf(Phdr)		*phdr;

	small_bound = sizeof(Elf(Ehdr)) + (self->segment_count * sizeof(Elf(Phdr)));
	i = 0;
	smallest = INT_MAX;
	while (i < self->segment_count)
	{
		smallest = Func(elfstream_segment_lowest)(self->segments, self->segment_count);
		if (smallest < 0)
		{
			printf("error: lowest segment is not in bounds\n");
			break ; // TODO: error?
		}
		DBG("coercing segment #%zu", smallest);
		Func(elfstream_segment_coerce)(self->segments + smallest, small_bound);
		DBG("writing segment #%zu", smallest);
		segment = &self->segments[smallest];
		phdr = ((Elf(Phdr) *) &segment->phdr32);
		offset = phdr->p_offset;
		Func(elfstream_write_content)(offset, segment->content, fd);
		DBG("wrote segment content at %#lx", offset);
		i++;
		DBG("written %zu/%zu segments", i, self->segment_count);
		small_bound = offset + elfstream_content_size(segment->content);
		phdr->p_offset = ((Elf(Off)) -1);
		// fsync(fd);
		// getchar();
	}
	return (ELFSTREAM_OK);
}

enum e_elfstream_error
Func(elfstream_write_segments)(t_elfstream *self, int fd)
{
	t_elf_segment			*segments;
	size_t					i;
	const Elf(Ehdr)			*hdr = (Elf(Ehdr) *) &self->ehdr32;
	enum e_elfstream_error	error;

	lseek(fd, hdr->e_phoff, SEEK_SET);
	DBG("writing segments at %#lx", hdr->e_phoff);
	segments = self->segments;
	i = 0;
	error = ELFSTREAM_OK;
	while (i < self->segment_count && !error)
	{
		DBG("writing segment header %zu/%zu", i + 1, self->segment_count);
		error = Func(elfstream_write_segment)(segments + i, fd);
		// fsync(fd);
		DBG("wrote segment header %zu", i + 1);
		// getchar();
		i++;
	}
	if (!error)
		error = Func(elfstream_write_segments_round)(self, fd);
	DBG("wrote segments (error? %d)", (int) error);
	return (error);
}

/*static inline*/ enum e_elfstream_error
Func(elfstream_write_section)(t_elf_section *self, int fd)
{
	const ssize_t			to_write = sizeof(Elf(Shdr));
	Elf(Shdr)				*shdr = (Elf(Shdr) *) &self->shdr32;

	//TODO: fix sizes
	DBG("writing section header");
	// __asm__("int3");
	DBG("sh_name (index): %d", shdr->sh_name);
	DBG("sh_type: %d", shdr->sh_type);
	DBG("sh_offset: %#lx", shdr->sh_offset);
	DBG("sh_size: %#lx", shdr->sh_size);
	DBG("sh_entsize: %#lx", shdr->sh_entsize);
	if (write(fd, shdr, to_write) != to_write)
		return (ELFSTREAM_IO);
	DBG("wrote section header");
	return (ELFSTREAM_OK);
}

enum e_elfstream_error
Func(elfstream_write_sections)(t_elfstream *self, int fd)
{
	size_t					i;
	const Elf(Ehdr)			*hdr = (Elf(Ehdr) *) &self->ehdr32;
	enum e_elfstream_error	error;

	DBG("writing sections at %#lx", hdr->e_shoff);
	lseek(fd, hdr->e_shoff, SEEK_SET); //TODO: change e_shoff
	i = 0;
	error = ELFSTREAM_OK;
	while (i < self->section_count && !error)
	{
		DBG("writing section %zu", i);
		error = Func(elfstream_write_section)(self->sections + i, fd);
		DBG("wrote section %zu", i);
		i++;
	}
	DBG("wrote sections (error? %d)", (int) error);
	return (error);
}

#undef ELF_BITNESS

// vim: set ft=c:
