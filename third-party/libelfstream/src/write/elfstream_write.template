/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   elfstream_write.template                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kiroussa <oss@xtrm.me>                     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/17 12:14:40 by kiroussa          #+#    #+#             */
/*   Updated: 2025/05/09 17:10:32 by kiroussa         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef ELF_BITNESS
# error "ELF_BITNESS not defined"
#endif

#define _APPEND(x, y) x##y
#define APPEND(x, y) _APPEND(x, y)

#define Elf(n) APPEND(APPEND(APPEND(Elf, ELF_BITNESS), _), n)
#define Func(n) APPEND(APPEND(n, _x), ELF_BITNESS)

enum e_elfstream_error
Func(elfstream_write_header)(t_elfstream *self, int fd)
{
	const ssize_t	to_write = sizeof(Elf(Ehdr));
	Elf(Ehdr)		*hdr;

	DBG("writing header");
	hdr = (Elf(Ehdr) *) &self->ehdr32;
	if (lseek(fd, 0, SEEK_SET) == -1)
		return (ELFSTREAM_IO);
	hdr->e_phnum = self->segment_count;
	hdr->e_shnum = self->section_count;
	//TODO: shstrndx
	if (write(fd, hdr, to_write) != to_write)
		return (ELFSTREAM_IO);
	DBG("wrote header");
	return (ELFSTREAM_OK);
}

static inline enum e_elfstream_error
Func(elfstream_write_segment)(t_elf_segment *self, int fd)
{
	const ssize_t			to_write = sizeof(Elf(Phdr));
	Elf(Phdr)				*phdr = (Elf(Phdr) *) &self->phdr32;

	//TODO: fix sizes
	DBG("writing segment header");
	if (write(fd, phdr, to_write) != to_write)
		return (ELFSTREAM_IO);
	DBG("wrote segment header");
	return (ELFSTREAM_OK);
}

static inline enum e_elfstream_error
Func(elfstream_write_content)(t_content_source *content, int fd)
{
	enum e_elfstream_error	error;
	// const off_t				curr = lseek(fd, 0, SEEK_CUR);

	DBG("writing content");
	error = ELFSTREAM_OK;
	while (content)
	{
		DBG("writing type %d", (int) content->type);
		error = content->write_fn(content, fd);
		if (error)
			break;
		// lseek(fd, curr + content->size, SEEK_SET);
		content = content->next;
	}
	DBG("wrote content");
	return (error);
}

enum e_elfstream_error
Func(elfstream_write_segments)(t_elfstream *self, int fd)
{
	t_elf_segment			*segments;
	size_t					i;
	const Elf(Ehdr)			*hdr = (Elf(Ehdr) *) &self->ehdr32;
	enum e_elfstream_error	error;

	DBG("writing segments");
	lseek(fd, hdr->e_phoff, SEEK_SET);
	segments = self->segments;
	i = 0;
	error = ELFSTREAM_OK;
	while (i < self->segment_count && !error)
	{
		DBG("writing segment %zu", i);
		error = Func(elfstream_write_segment)(segments + i, fd);
		if (!error)
			error = Func(elfstream_write_content)(segments[i].content, fd);
		DBG("wrote segment %zu", i);
		i++;
	}
	DBG("wrote segments");
	return (error);
}

static inline enum e_elfstream_error
Func(elfstream_write_section)(t_elf_section *self, int fd)
{
	const ssize_t			to_write = sizeof(Elf(Shdr));
	Elf(Shdr)				*shdr = (Elf(Shdr) *) &self->shdr32;

	//TODO: fix sizes
	DBG("writing section header");
	if (write(fd, shdr, to_write) != to_write)
		return (ELFSTREAM_IO);
	DBG("wrote section header");
	return (ELFSTREAM_OK);
}

enum e_elfstream_error
Func(elfstream_write_sections)(t_elfstream *self, int fd)
{
	t_elf_section			*sections;
	size_t					i;
	const Elf(Ehdr)			*hdr = (Elf(Ehdr) *) &self->ehdr32;
	enum e_elfstream_error	error;

	DBG("writing sections");
	lseek(fd, hdr->e_shoff, SEEK_SET);
	sections = self->sections;
	i = 0;
	error = ELFSTREAM_OK;
	while (i < hdr->e_shnum && !error)
	{
		DBG("writing section %zu", i);
		error = Func(elfstream_write_section)(sections + i, fd);
		DBG("wrote section %zu", i);
		i++;
	}
	DBG("wrote sections");
	return (error);
}

#undef ELF_BITNESS

// vim: set ft=c:
