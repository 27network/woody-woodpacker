; **************************************************************************** ;
;                                                                              ;
;                                                         :::      ::::::::    ;
;    smlz.entry.s                                       :+:      :+:    :+:    ;
;                                                     +:+ +:+         +:+      ;
;    By: kiroussa <oss@xtrm.me>                     +#+  +:+       +#+         ;
;                                                 +#+#+#+#+#+   +#+            ;
;    Created: 2025/05/26 21:31:42 by kiroussa          #+#    #+#              ;
;    Updated: 2025/07/18 18:26:01 by kiroussa         ###   ########.fr        ;
;                                                                              ;
; **************************************************************************** ;

bits 32
default rel

_woody_decompress_smlz:
	jmp		smlz_decompression


g_target_start		dq 0x42
g_code				db 0x42
bit_swap_LU			db 0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0
					db 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0
					db 0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8
					db 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8
					db 0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4
					db 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4
					db 0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC
					db 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC
					db 0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2
					db 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2
					db 0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA
					db 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA
					db 0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6
					db 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6
					db 0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE
					db 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE
					db 0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1
					db 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1
					db 0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9
					db 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9
					db 0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5
					db 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5
					db 0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED
					db 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD
					db 0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3
					db 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3
					db 0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB
					db 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB
					db 0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7
					db 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7
					db 0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF
					db 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF

smlz_decompression:
	push	ebx
	call	get_args
	xor		ecx, ecx
	call	get_block_infos

	call	decompression_loop

	pop		ebx
	ret

get_args:
	mov		edi, ecx
	mov		esi, [esp + 0x10]

	ret

decompression_loop:
	push	edx
	push	ebx
	call	check_if_last_block
	pop		edx

	push	eax
	push	edx
	push	ecx
	xor		ecx, ecx

	;get block_header address into eax register
	lea		eax, [esi]

	;make esi point right next to the block header
	shr		edx, 0x03	;RDX = ebx (ebx is saved into RDX in case of remaining != 0)
	add		esi, edx

	call	decompress_block_loop

	pop		ecx
	pop		edx
	pop		eax
	pop		edx

	inc		ecx
	cmp		ecx, edx
	jl		decompression_loop

	ret

decompress_block_loop:
	push	ebx

	call	get_block_header
	call	process_block

	shr		edx, 1
	pop		ebx
	inc		ecx
	cmp		ecx, ebx
	jl		decompress_block_loop

	ret

process_block:
	push	edx
	call	compressed_byte_case	;esi is incremented inside compressed_byte_case
	pop		edx
	call	decompressed_byte_case	;esi is incremented inside decompressed_byte_case

	ret

compressed_byte_case:
	test	edx, 0x01
	jz		ignore_case

	movzx	edx, word [esi]				;offset
	movzx	ebx, word [esi + 0x02]		;len

	push	eax
	push	ecx
	xor		ecx, ecx
	call	compressed_byte_loop

	pop		ecx
	pop		eax
	ret

compressed_byte_loop:
	sub		edi, edx
	add		edi, ecx
	movzx	eax, byte [edi]
	sub		edi, ecx
	add		edi, edx
	mov		[edi + ecx], al

	inc		ecx
	cmp		ecx, ebx
	jl		compressed_byte_loop

	add		edi, ebx
	add		esi, 0x04

	ret

decompressed_byte_case:
	test	edx, 0x01
	jnz		ignore_case

	movzx	ebx, byte [esi]
	mov		[edi], ebx

	inc		esi
	inc		edi

	ret

ignore_case:
	ret

check_if_last_block:
	dec		edx
	cmp		ecx, edx
	je		last_block
	inc		edx

	ret

last_block:
	inc		edx
	cmp		eax, 0
	jne		remaining

	ret

remaining:
	mov		ebx, eax

	ret

get_block_header:
	test	ecx, 0x7
	jz		modulo_8

	ret

modulo_8:
	movzx	ebx, byte [eax]
	inc		eax

	;get bit-swaped block_header into ebx register
	lea		edx, [rel bit_swap_LU]
	push	eax
	movzx	eax, byte [edx + ebx]
	mov		edx, eax
	pop		eax

	ret

get_block_infos:
	movzx	edx, word [esi + 0x04]		;nblocks
	movzx	ebx, word [esi + 0x06]		;block_size
	movzx	eax, word [esi + 0x08]		;remaining
	add		esi, 0x0c

	ret
