; **************************************************************************** ;
;                                                                              ;
;                                                         :::      ::::::::    ;
;    smlz.entry.s                                       :+:      :+:    :+:    ;
;                                                     +:+ +:+         +:+      ;
;    By: kiroussa <oss@xtrm.me>                     +#+  +:+       +#+         ;
;                                                 +#+#+#+#+#+   +#+            ;
;    Created: 2025/05/26 21:31:42 by kiroussa          #+#    #+#              ;
;    Updated: 2025/05/26 21:33:27 by kiroussa         ###   ########.fr        ;
;                                                                              ;
; **************************************************************************** ;

get_bit_swap_LU:
	call get_bit_swap_LU_callback

bit_swap_LU	db 0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0
		   	db 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0
		   	db 0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8
		   	db 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8
		   	db 0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4
		   	db 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4
		   	db 0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC
		   	db 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC
		   	db 0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2
		   	db 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2
		   	db 0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA
		   	db 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA
		   	db 0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6
		   	db 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6
		   	db 0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE
		   	db 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE
		   	db 0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1
		   	db 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1
		   	db 0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9
		   	db 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9
		   	db 0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5
		   	db 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5
		   	db 0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED
		   	db 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD
		   	db 0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3
		   	db 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3
		   	db 0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB
		   	db 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB
		   	db 0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7
		   	db 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7
		   	db 0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF
		   	db 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF

_woody_decompress_smlz:
	;lea	RDI, [rel g_target_start]
	mov		RSI, [RAX + OFFSET_WOODY_START_BASE]
	mov		RDI, [RAX + OFFSET_SEGMENTS_WRITE_OFFSET]
	add		RDI, RSI

	;lea	RSI, [rel g_code]
	mov		RSI, [RAX + OFFSET_SEGMENTS_CONTENT]

	xor		RCX, RCX
	call	get_block_infos

	call	decompression_loop

	ret

decompression_loop:
	push	RDX
	push	RBX
	call	check_if_last_block
	pop		RDX

	push	RAX
	push	RDX
	push	RCX
	xor		RCX, RCX

	;get block_header address into RAX register
	lea		RAX, [RSI]

	;make RSI point right next to the block header
	shr		RDX, 0x03	;RDX = RBX (RBX is saved into RDX in case of remaining != 0)
	add		RSI, RDX

	call	decompress_block_loop

	pop		RCX
	pop		RDX
	pop		RAX
	pop		RDX

	inc		RCX
	cmp		RCX, RDX
	jl		decompression_loop

	ret

decompress_block_loop:
	push	RBX

	call	get_block_header
	call	process_block

	shr		RDX, 1
	pop		RBX
	inc		RCX
	cmp		RCX, RBX
	jl		decompress_block_loop

	ret

process_block:
	push	RDX
	call	compressed_byte_case	;RSI is incremented inside compressed_byte_case
	pop		RDX
	call	decompressed_byte_case	;RSI is incremented inside decompressed_byte_case

	ret

compressed_byte_case:
	test	RDX, 0x01
	jz		ignore_case

	movzx	RDX, word [RSI]				;offset
	movzx	RBX, word [RSI + 0x02]		;len

	push	RAX
	push	RCX
	xor		RCX, RCX
	call	compressed_byte_loop

	pop		RCX
	pop		RAX
	ret

compressed_byte_loop:
	sub		RDI, RDX
	add		RDI, RCX
	movzx	RAX, byte [RDI]
	sub		RDI, RCX
	add		RDI, RDX
	mov		[RDI + RCX], al

	inc		RCX
	cmp		RCX, RBX
	jl		compressed_byte_loop

	add		RDI, RBX
	add		RSI, 0x04

	ret

decompressed_byte_case:
	test	RDX, 0x01
	jnz		ignore_case

	movzx	RBX, byte [RSI]
	mov		[RDI], RBX

	inc		RSI
	inc		RDI

	ret

ignore_case:
	ret

check_if_last_block:
	dec		RDX
	cmp		RCX, RDX
	je		last_block
	inc		RDX

	ret

last_block:
	inc		RDX
	cmp		RAX, 0
	jne		remaining

	ret

remaining:
	mov		RBX, RAX

	ret

get_block_header:
	test	RCX, 0x7
	call	modulo_8

	ret

modulo_8:
	movzx	RBX, byte [RAX]
	inc		RAX
	jmp     get_bit_swap_LU

get_bit_swap_LU_callback:
	pop RDX	; bit_swap_LU
	push	RAX
	movzx	RAX, byte [RDX + RBX]
	mov		RDX, RAX
	pop		RAX

	ret

get_block_infos:
	movzx	RDX, word [RSI + 0x04]		;nblocks
	movzx	RBX, word [RSI + 0x06]		;block_size
	movzx	RAX, word [RSI + 0x08]		;remaining
	add		RSI, 0x0c

	ret
